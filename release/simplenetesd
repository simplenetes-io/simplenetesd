#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.4.0 | https://space.sh
#
# Node: /_cmdline/
# Use simplenetesd as a standalone cmd line tool

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
SNTD_CMDLINE()
{
    local _SPACE_NAME="SNTD_CMDLINE"

    if [ "${1:-}" = "help" ] || [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
        USAGE
        return
    fi

    if [ "${1:-}" = "version" ] || [ "${1:-}" = "-V" ]; then
        VERSION
        return
    fi

    DAEMON_MAIN "$@"
}

USAGE()
{
    local _SPACE_NAME="USAGE"
    printf "%s\\n" "Usage:

    simplenetesd -h
        Output this help

    simplenetesd -V|--version
        Output version

    simplenetesd [hosthome]

        hosthome (optional)
            Path to directory of the cluster root directory.
            If provided the program will run pods only for that cluster project,
            if the process is run as root then ramdisks will be available.

            If the hosthome argument is left out then the process must be run as root and it
            will then search for cluster directories for all users and manage the lifecycles
            for all the cluster projects on the host.

"
}

VERSION()
{
    local _SPACE_NAME="VERSION"
    printf "%s\\n" "Simplenetesd 0.3.0"
}

DAEMON_MAIN()
{
    local _SPACE_NAME="DAEMON_MAIN"

    local hostHome="${1:-}"

    # If not root and no dir given then exit.
    if [ "$(id -u)" != 0 ]; then
        if [ -z "${hostHome}" ]; then
            PRINT "The daemon has to be run as root, unless it is meant to be run for a single cluster project then provide the HOSTHOME dir as first argument" "error" 0
            return 1
        fi
    fi

    local _EXIT=0
    local main_pids=""
    trap _TRAP_TERM_MAIN TERM INT HUP

    # If directory given as argument then don't run this in Daemon mode,
    # pass it directly to _DAEMON_RUN to run for single user.
    # Regardless if running as root or not.
    if [ -n "${hostHome}" ]; then
        # Run for single user
        hostHome="$(FILE_REALPATH "${hostHome}")"
        if [ ! -d "${hostHome}/pods" ]; then
            PRINT "The specified hostHome '${hostHome}' is lacking a 'pods' dir" "error" 0
            return 1
        fi
        PRINT "Running service for single host home. PID: $$" "info" 0
        PRINT "Adding watch to ${hostHome}" "info" 0
        local pid=
        _DAEMON_RUN "${hostHome}" &
        pid=$!
        main_pids="${main_pids}${main_pids:+ }${pid}"

        # Wait until signalled to exit.
        while [ "${_EXIT}" -eq 0 ]; do
            sleep 1
        done
    else
        PRINT "Running service for all users. PID: $$" "info" 0

        local clustersDone=""

        while [ "${_EXIT}" -eq 0 ]; do
            local file=
            for file in $(find /home -mindepth 3 -maxdepth 3 -type f -name cluster-id.txt); do
                local hostHome="${file%/*}"
                if [ ! -d "${hostHome}/pods" ]; then
                    continue
                fi
                # Check if we already have this cluster.
                if STRING_ITEM_INDEXOF "${clustersDone}" "${hostHome}"; then
                    continue
                fi

                clustersDone="${clustersDone}${clustersDone:+ }${hostHome}"
                PRINT "Adding watch to ${hostHome}" "info" 0

                local pid=
                _DAEMON_RUN "${hostHome}" &
                pid=$!
                main_pids="${main_pids}${main_pids:+ }${pid}"
            done
            sleep 3
        done
    fi

    trap - TERM INT HUP

    # Kill subprocesses, if not already killed.
    local pid=
    for pid in ${main_pids}; do
        kill -s HUP "${pid}" 2>/dev/null
    done

    # Wait for sub processes to exit
    wait ${main_pids} 2>/dev/null >&2

    # Set the exit status to error if this was not a user triggered shutdown.
    [ "${_EXIT}" -eq 1 ]
    return
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

_DAEMON_RUN()
{
    local _SPACE_NAME="_DAEMON_RUN"

    local hostHome="${1}"
    shift

    # Declaring some shared variables here:
    local _USER=
    if ! _USER="$(FILE_STAT "${hostHome}" "%U")"; then
        PRINT "Could not stat owner of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi
    local _USERUID=
    if ! _USERUID="$(FILE_STAT "${hostHome}" "%u")"; then
        PRINT "Could not stat owner of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi

    local _USERGID=
    if ! _USERGID="$(FILE_STAT "${hostHome}" "%g")"; then
        PRINT "Could not stat owner group of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi

    if [ "$(id -u)" = 0 ]; then
        # If running as root make sure /run/user/UID exists properly, podman can throw errors otherwise.
        local runDir="/run/user/${_USERUID}"
        if [ ! -d "${runDir}" ]; then
            mkdir -p "${runDir}"
            chown "${_USERUID}:${_USERGID}" "${runDir}"
            chmod 700 "${runDir}"
        fi
        unset runDir
    fi

    local _PODPATTERNS="${hostHome}/pods,.*/release/[^.].*/.*.state"
    local _PROXYCONF="${hostHome}/portmappings.conf"
    local _SUBPROCESS_LOG_LEVEL="${SPACE_LOG_LEVEL:-2}"  # The SPACE_LOG_LEVEL of the subprocesses pod scripts.
    local _BUSYLIST=""
    local _PODS=""
    local _CURRENT_STATES=""

    local _PHASE="normal"

    # Bash needs INT to be ignored in subprocesses.
    trap '' INT

    trap _TRAP_TERM HUP

    while [ "${_PHASE}" = "normal" ]; do
        if ! _DAEMON_ITERATE; then
            _PHASE="shutdown"
            continue
        fi
        sleep 6
    done

    trap - HUP

    # Perform graceful shutdown.
    # Wait for all subprocesses to exit.
    PRINT "Initiating graceful shutdown for ${hostHome}" "info" 0
    while [ -n "${_BUSYLIST}" ]; do
        _UPDATE_BUSY_LIST
        sleep 2
    done

    PRINT "Shutdown done for ${hostHome}" "info" 0
}

_TRAP_TERM_MAIN()
{
    local _SPACE_NAME="_TRAP_TERM_MAIN"
    _EXIT=1
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"
    shift

    local pwd="${1:-$PWD}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${pwd}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

_DAEMON_ITERATE()
{
    local _SPACE_NAME="_DAEMON_ITERATE"

    if ! _FETCH_POD_FILES; then
        PRINT "Error in fetching pod files" "error" 0
        return 1
    fi

    if ! _UPDATE_BUSY_LIST; then
        PRINT "Cannot update busy list" "error" 0
        return 1
    fi

    if ! _SPAWN_PROCESSES; then
       PRINT "Could not spawn process" "error" 0
        return 1
    fi

    if ! _WRITE_PROXY_CONFIG; then
        PRINT "Could not write proxy config" "error" 0
        return 1
    fi
}

_UPDATE_BUSY_LIST()
{
    local _SPACE_NAME="_UPDATE_BUSY_LIST"

    local newList=""
    local tuple=
    for tuple in ${_BUSYLIST}; do
        local nakedFile="${tuple%%,*}"
        local pid="${tuple##*,}"
        # Check if the process is still alive.
        if kill -0 "${pid}" 2>/dev/null; then
            newList="${newList}${newList:+ }${nakedFile},${pid}"
        else
            # The process ended, check if it should be running and exit code was > 0, then put it back for retry.
            # Otherwise if the state is not "running" remove any ramdisks this process has created.
            # Get exit code
            local exitCode=
            wait "${pid}"
            exitCode="$?"
            PRINT "Spawn process exited for ${nakedFile} with PID ${pid}, exit code: ${exitCode}." "debug" 0
            local stateFile="${nakedFile}.state"
            local state="$(cat "${stateFile}")"
            if [ "${state}" = "running" ]; then
                if [ "${exitCode}" -gt 0 ]; then
                    # Retry running this.
                    PRINT "Retry running ${nakedFile}" "info" 0
                    local actionFile="${nakedFile}.action"
                    printf "%s\\n" "rerun" >"${actionFile}"
                fi
            else
                # Remove ramdisks, if simplenetesd running as root.
                if [ "$(id -u)" = "0" ]; then
                    local podDir="${nakedFile%/*}"
                    _DESTROY_RAMDISKS "${podDir}"
                fi
            fi
        fi
    done
    _BUSYLIST="${newList}"
}

_TRAP_TERM()
{
    local _SPACE_NAME="_TRAP_TERM"
    _PHASE="shutdown"
}

FILE_STAT()
{
    local _SPACE_NAME="FILE_STAT"

    local file="${1}"
    shift

    local format="${1}"
    shift

    #
    # Check for BSD stat
    if command -v "pkg" >/dev/null || command -v "brew" >/dev/null ; then
        # Translate format options
        format=$(printf "%s" "${format}" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f "${format}" "${file}"
    else
        stat -c "${format}" "${file}"
    fi

    if [ "$?" -gt 0 ]; then
        PRINT "Failed to stat file: ${file}." "error"
        return 1
    fi
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

_FETCH_POD_FILES()
{
    local _SPACE_NAME="_FETCH_POD_FILES"
    local tuple=
    for tuple in ${_PODPATTERNS}; do
        local basedir="${tuple%%,*}"
        local pattern="${tuple##*,}"
        local stateFiles=
        if ! stateFiles="$(find "${basedir}" -regex "${pattern}" 2>/dev/null)"; then
            return 1
        fi
        local stateFile=
        _PODS=""
        for stateFile in ${stateFiles}; do
            local nakedFile="${stateFile%.state}"
            # Check so that the state file has a pod buddie file,
            # if so store it.
            if [ -f "${nakedFile}" ]; then
                _PODS="${_PODS}${_PODS:+ }${nakedFile}"
            fi
        done
    done
}

_SPAWN_PROCESSES()
{
    local _SPACE_NAME="_SPAWN_PROCESSES"

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list, skip for now
                continue 2
            fi
        done

        local actionFile="${nakedFile}.action"
        local action=
        if [ -f "${actionFile}" ]; then
            action="$(cat "${actionFile}")"
            rm "${actionFile}"
            # Check the action so it is valid:
            if [ "${action%[ ]*}" = "rerun" ]; then
                if ! STRING_IS_ALL "${action}" "a-z0-9_ "; then
                    action=
                fi
            else
                action=
            fi
            if [ -z "${action}" ]; then
                PRINT "Action not recognized for ${nakedFile}" "error" 0
            fi
        fi

        local stateFile="${nakedFile}.state"
        local state="$(cat "${stateFile}")"
        local stateChanged="false"

        if _SPAWN_STATE_CHANGED "${nakedFile}" "${state}"; then
            stateChanged="true"
            PRINT "State changed. Exec ${nakedFile} ${state}" "info" 0
        fi

        if [ "${stateChanged}" = "true" ] && [ -n "${action}" ]; then
            PRINT "Action '${action}' provided but pod state did also change, so ignoring action. For ${nakedFile}" "warning" 0
            action=""
        fi

        if [ "${state}" = "running" ]; then
            if [ -n "${action}" ]; then
                PRINT "Action '${action}' provided for ${nakedFile}" "info" 0
            fi
        else
            if [ -n "${action}" ]; then
                PRINT "Action '${action}' provided but pod is not in 'running' state for ${nakedFile}" "warning" 0
                # Do not perform actions on non running containers
                action=""
            fi
        fi

        if [ "${stateChanged}" = "true" ] ||
           [ -n "${action}" ]; then
            if ! _SPAWN_PROCESS "${nakedFile}" "${state}" "${action}"; then
                PRINT "Could not spawn process for ${nakedFile}" "error" 0
                return 0
            fi
        fi
    done
}

_WRITE_PROXY_CONFIG()
{
    local _SPACE_NAME="_WRITE_PROXY_CONFIG"
    if [ -z "${_PROXYCONF}" ]; then
        return 0
    fi

    local nl="
"
    local contents=""
    local nakedFile=
    for nakedFile in ${_PODS}; do
        # Check so state is running
        local stateFile="${nakedFile}.state"
        if [ ! -f "${stateFile}" ]; then
            continue
        fi
        local state="$(cat "${stateFile}")"
        if [ "${state}" != "running" ]; then
            continue
        fi

        # Check readiness
        local proxyFile="${nakedFile}.portmappings.conf"

        local statusFile="${nakedFile}.status"
        if [ ! -f "${statusFile}" ]; then
            continue
        fi
        local readiness="$(grep "^readiness:" "${statusFile}" |cut -d' ' -f2)"
        if [ "${readiness}" = "1" ]; then
            # Check that last update time is not too old
            local updated="$(grep "^updated:" "${statusFile}" |cut -d' ' -f2)"
            if [ -n "${updated}" ]; then
                local ts="$(date +%s)"
                # Allow a maximum 10 minutes old update.
                if [ $((ts-updated > 600)) -eq 1 ]; then
                    continue
                fi
            fi
            if [ -f "${proxyFile}" ]; then
                contents="${contents}${contents:+ $nl}$(cat "${proxyFile}")"
            fi
        fi
    done

    local proxyConf="$(mktemp 2>/dev/null || mktemp -t 'sometmpdir')"

    printf "%s\\n" "${contents}" |sort >"${proxyConf}"

    if diff "${_PROXYCONF}" "${proxyConf}" >/dev/null 2>&1; then
        rm "${proxyConf}"
        return 0
    fi

    mv -f "${proxyConf}" "${_PROXYCONF}"
    # Make file readable by regular user running the proxy pod.
    chmod 644 "${_PROXYCONF}"
}

_DESTROY_RAMDISKS()
{
    local _SPACE_NAME="_DESTROY_RAMDISKS"

    if [ -d "${podDir}/ramdisk" ]; then
        local dir=
        for dir in $(find "${podDir}/ramdisk" -maxdepth 1 -mindepth 1 -type d 2>/dev/null); do
            if mountpoint -q "${dir}"; then
                PRINT "Unmount ramdisk ${dir}" "info" 0
                umount "${dir}"
            fi
        done
    fi
}

_SPAWN_PROCESS()
{
    local _SPACE_NAME="_SPAWN_PROCESS"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local action="${1}"
    shift

    local podFile="${nakedFile}"

    local _HOME="${HOME}"
    local exec="sh -c"
    if [ "$(id -u)" = "0" ]; then
        # Drop priviligies
        exec="setpriv --reuid ${_USERUID} --regid ${_USERGID} --init-groups sh -c"
        _HOME="/home/${_USER}"
    fi

    local command=

    # If we have an action given, then we hijack the command at this point.
    if [ -n "${action}" ]; then
        command="${action}"
    elif [ "${state}" = "running" ]; then
        command="run"
        if [ "$(id -u)" = "0" ]; then
            # Check if to create ramdisks for this pod
            # Note: instead of running `pod create-ramdisks` as root and have it done with,
            # we drop privileges and get the ramdisk config. This is a security consideration
            # because we don't want to run any user provided pod code as root.
            local ramdisks=
            ramdisks="$(USER="${_USER}" HOME="${_HOME}" SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} create-ramdisks -l")"
            if [ -n "${ramdisks}" ]; then
                local podDir="${nakedFile%/*}"
                local ramdisk=
                for ramdisk in ${ramdisks}; do
                    local name="${ramdisk%:*}"
                    local size="${ramdisk#*:}"
                    local error=
                    if ! error="$(_CREATE_RAMDISK "${podDir}" "${name}" "${size}" 2>&1)"; then
                        PRINT "Could not create ramdisk ${name}:${size} in ${podDir}, Error: ${error}" "error" 0
                        return 1
                    else
                        PRINT "Created ramdisk ${name}:${size} in ${podDir}" "info" 0
                    fi
                done
            fi
        fi
    elif [ "${state}" = "stopped" ]; then
        command="stop"
    elif [ "${state}" = "removed" ]; then
        command="rm"
    else
        PRINT "State file has unknown state." "debug" 0
        return 0
    fi

    local hash=
    if ! STRING_HASH "${nakedFile}" "hash"; then
        return 1
    fi

    local pid=
    (
        local error=
        local exitCode=
        # If running as root we will drop privileges here, thanks to ${exec}.
        error="$(USER="${_USER}" HOME="${_HOME}" SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ${command}" 2>&1)"
        exitCode="$?"
        if [ "${exitCode}" -gt 0 ]; then
            PRINT "Could not exec ${podFile} ${command}. Exit code: ${exitCode}. Error: ${error}" "error" 0
            return "${exitCode}"
        fi
    )&
    pid=$!

    _BUSYLIST="${_BUSYLIST}${_BUSYLIST:+ }${nakedFile},${pid}"
}

_SPAWN_STATE_CHANGED()
{
    local _SPACE_NAME="_SPAWN_STATE_CHANGED"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local prevState=""
    local line="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -m1 "^${nakedFile} ")"

    if [ -n "${line}" ]; then
        prevState="${line##*[ ]}"
        _CURRENT_STATES="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -v "^${nakedFile} ")"
    fi

    # Save state
    local nl="
"
    _CURRENT_STATES="${_CURRENT_STATES}${_CURRENT_STATES:+$nl}${nakedFile} ${state}"

    # Set return status
    [ "${prevState}" != "${state}" ]
}

STRING_IS_ALL()
{
    local _SPACE_NAME="STRING_IS_ALL"

    local __str="${1}"
    shift

    local __pattern="${1}"
    shift

    local __m="[!${__pattern}]"
    case "${__str}" in
        (*${__m}*)
            return 1
            ;;
        *)
            ;;
    esac
}

STRING_HASH()
{
    local _SPACE_NAME="STRING_HASH"

    local __str="${1}"
    shift

    local __outvar="${1}"
    shift

    local SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        SHASUMBIN="sha256sum"
    elif command -v shasum >/dev/null; then
        SHASUMBIN="shasum -a 256"
    fi

    if [ -z "${SHASUMBIN}" ]; then
        return 1
    fi

    local __hash=
    __hash=$(printf "%s\\n" "${__str}" |${SHASUMBIN}) || { return 1; }
    __hash="${__hash%%[ ]*}"
    eval "${__outvar}=\"\${__hash}\""
}

_CREATE_RAMDISK()
{
    local _SPACE_NAME="_CREATE_RAMDISK"

    if [ ! -d "${podDir}/ramdisk" ]; then
        mkdir "${podDir}/ramdisk"
        chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk"
    fi

    if [ ! -d "${podDir}/ramdisk/${name}" ]; then
        mkdir "${podDir}/ramdisk/${name}"
        chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk/${name}"
    fi

    if mountpoint -q "${podDir}/ramdisk/${name}"; then
        # Already exists.
        return 0
    fi

    # If the pod was run without daemon prior and it created "fake" ramdisks which might be lingering from an abrupt shutdown,
    # that is fine, since a mount will shadow the existing directory contents.

    if ! mount -t tmpfs -o size="${size}" tmpfs "${podDir}/ramdisk/${name}"; then
        return 1
    fi

    chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk/${name}"
    chmod 700 "${podDir}/ramdisk/${name}"
}

main()
{
    SNTD_CMDLINE "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /_cmdline/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /_cmdline/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
