#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /run/
# Run the Simplenetes Daemon to manage pods for all users
# This target is meant to be run from the init system (systemd or other) to manage the pod life cycles of all users pods.
# The user should be root.
# The daemon will figure out where to find pods by looking in each users $HOME/.simplenetes-daemon.conf.
# If a user changes the .simplenetes-daemon.conf then the daemon needs to be restarted for the change to take effect.
# For each user having such a config the daemon will spawn a specific process managing the pods for that user.
# It's responsibilities are:
# 1) Check each Pod's state file to see what state it should have and invoke the pod script to make sure it has that state.
#    The daemon will also create any ramdisks for the pod (if the daemon is run as root).
# 2) Detect changes in pods config directories and invoke the pod script to signal the containers mounting those configs.
# 3) Generate proxy configurations:
#     i) Probe each Pod which has the state "running" for any clusterPorts.
#     ii) For each running Pod with clusterPorts run the Readiness probe.
#     iii) For each ready Pod generate the config.
#     iiii) If aggregated config was changed, SIGHUP the hostproxy.
# 4) Run the Liveness probe on each pod which has the state "running".
# Note:
#     There is a way of running this Daemon as a foreground process for a single user by adding a directory of the hosthome as argument to the daemon.
#     This is a special behaviour and is only meant to be used in dev mode.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
DAEMON_MAIN()
{
    local _SPACE_NAME="DAEMON_MAIN"

    local hostHome="${1:-}"

    local _LOGFILETAGS="$(mktemp 2>/dev/null || mktemp -t 'sometmpdir')"

    # If not root and no dir given then exit.
    if [ $(id -u) != 0 ]; then
        if [ -z "${hostHome}" ]; then
            _LOG "The daemon has to be run as root, unless it is meant to be run for a single user then provide the HOSTHOME dir as first argument" "fatal"
            return 1
        fi
    fi

    local _EXIT=0
    local main_pids=""
    trap _TRAP_TERM_MAIN TERM INT

    # If directory given as argument then don't run this in Daemon mode,
    # pass it directly to _DAEMON_RUN to run for single user.
    # Regardless if running as root or not.
    if [ -n "${hostHome}" ]; then
        # Run for single user
        hostHome="$(FILE_REALPATH "${hostHome}")"
        _LOG "hostHome is ${hostHome}" "info"
        if [ ! -d "${hostHome}/pods" ]; then
            _LOG "The specified hostHome is lacking a 'pods' dir" "fatal"
            return 1
        fi
        _LOG "Running for single user in foreground (dev mode). PID: $$" "info"
        _LOG "Adding watch to ${hostHome}" "info"
        local pid=
        _DAEMON_RUN "${hostHome}" &
        pid=$!
        main_pids="${main_pids}${main_pids:+ }${pid}"
        while true; do
            sleep 1
            # This loop will end if the single sub process exists.
            if kill -0 ${main_pids} 2>/dev/null && [ "${_EXIT}" -eq 0 ]; then
                continue
            fi
            # Wait for sub processes to exit
            wait ${main_pids} 2>/dev/null >&2
            break
        done

        # Set the exit status to error if this was not a user triggered shutdown.
        [ "${_EXIT}" -eq 1 ]
        return
    fi

    _LOG "Running as a system daemon for all users. PID: $$" "info"

    local usersDone=""

    while [ "${_EXIT}" -eq 0 ]; do
        local dir=
        for dir in /home/*; do
            if [ ! -d "${dir}" ]; then
                continue
            fi
            local file="${dir}/.simplenetes-daemon.conf"
            if [ ! -f "${file}" ]; then
                continue
            fi

            # Check if we already have this user.
            if STRING_ITEM_INDEXOF "${usersDone}" "${dir}"; then
                continue
            fi
            usersDone="${usersDone}${usersDone:+ }${dir}"

            local hostHome="$(cat "${file}")"
            hostHome="$(FILE_REALPATH "${hostHome}")"
            _LOG "Adding watch to ${hostHome}" "info"

            local pid=
            _DAEMON_RUN "${hostHome}" &
            pid=$!
            main_pids="${main_pids}${main_pids:+ }${pid}"
        done
        sleep 1
    done

    # Wait for sub processes to exit
    wait ${main_pids} 2>/dev/null >&2
}

_LOG()
{
    local _SPACE_NAME="_LOG"

    local message="${1}"
    shift

    local level="${1}"
    shift

    # The tag can be used to have different formatted messages group together.
    # If no tag provided the message is the tag which means it won't repeat it self.
    local tag="${1:-${message}}"

    # Check if this tag already exists, of so check if the level is the same.
    local hash=
    STRING_HASH "${tag}" "hash"

    # Check if hash is present
    local row=
    local level2=
    if row="$(grep "^${hash}\>" "${_LOGFILETAGS}" 2>/dev/null)"; then
        level2="${row#*[ ]}"
    fi

    if [ "${level}" != "${level2}" ]; then
        local logtext="$(grep -v "^${hash}\>" "${_LOGFILETAGS}")"
        printf "%s\\n%s\\n" "${logtext}" "${hash} ${level}" >"${_LOGFILETAGS}"
        if [ "${level}" = "fatal" ]; then
            level="error"
        fi
        PRINT "${message}" "${level}" 0
    fi
}

_DAEMON_RUN()
{
    local _SPACE_NAME="_DAEMON_RUN"

    local hostHome="${1}"
    shift

    # Declaring some shared variables here:
    local _USER=
    if ! _USER="$(FILE_STAT "${hostHome}" "%U")"; then
        _LOG "Could not stat owner of directory ${hostHome}, will not run this instance" "error"
        return 1
    fi
    local _PODPATTERNS="${hostHome}/pods,.*/release/.*/.*.state"
    local _PROXYCONF="${hostHome}/proxy.conf"
    local _SUBPROCESS_LOG_LEVEL=2  # The SPACE_LOG_LEVEL of the subprocesses pod scripts.
    local _BUSYLIST=""
    local _PODS=""
    local _CONFIGCHKSUMS=""
    local _CONFIGSCHANGED=""
    local _TMPDIR=
    local _STARTTS="$(date +%s)"

    # Global:
    _PHASE="normal"

    trap _TRAP_TERM HUP

    while true; do
        if [ "${_PHASE}" = "normal" ]; then
            if ! _DAEMON_ITERATE; then
                _PHASE="shutdown"
                continue
            fi
            sleep 6
        elif [ "${_PHASE}" = "shutdown" ]; then
            # Perform graceful shutdown.
            # Wait for all subprocesses to exit.
            _LOG "Initiating graceful shutdown for ${hostHome}" "info"
            _UPDATE_BUSY_LIST
            if [ -z "${_BUSYLIST}" ]; then
                _LOG "Shutdown done for ${hostHome}" "info"
                return 1
            fi
            sleep 2
        fi
    done
}

_TRAP_TERM_MAIN()
{
    local _SPACE_NAME="_TRAP_TERM_MAIN"

    trap - TERM INT

    _LOG "Kill off all daemon processes: ${main_pids}" "info"

    local pid=
    for pid in ${main_pids}; do
        kill -s HUP "${pid}" 2>/dev/null
    done

    # This will trigger the loop to end.
    _EXIT=1
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${PWD}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

STRING_HASH()
{
    local _SPACE_NAME="STRING_HASH"

    local __str="${1}"
    shift

    local __outvar="${1}"
    shift

    local SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        SHASUMBIN="sha256sum"
    elif command -v shasum >/dev/null; then
        SHASUMBIN="shasum -a 256"
    fi

    if [ -z "${SHASUMBIN}" ]; then
        return 1
    fi

    local __hash=
    __hash=$(printf "%s\\n" "${__str}" |${SHASUMBIN}) || { return 1; }
    __hash="${__hash%%[ ]*}"
    eval "${__outvar}=\"\${__hash}\""
}

_DAEMON_ITERATE()
{
    local _SPACE_NAME="_DAEMON_ITERATE"

    # We recreate the tmpdir if it has been removed, since this is a long running usage of tmp it might get removed at some point.
    if [ -z "${_TMPDIR}" ] || [ ! -d "${_TMPDIR}" ]; then
        _TMPDIR="$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')"
    fi

    if ! _FETCH_POD_FILES; then
        _LOG "Error in fetching pod files" "error"
        return 1
    fi

    if ! _UPDATE_BUSY_LIST; then
        _LOG "Cannot update busy list" "error"
        return 1
    fi

    if ! _CHECK_CONFIG_CHANGES; then
        _LOG "Could not check pod config changes" "error"
        return 1
    fi

    if ! _SPAWN_PROCESSES; then
       _LOG "Could not spawn process" "error"
        return 1
    fi

    # Wait at least 10 seconds before updating the proxy.conf since it may flicker to empty otherwise on startup.
    local ts="$(date +%s)"
    if [ "$((ts-_STARTTS >10000))" -eq 1 ]; then
        if ! _WRITE_PROXY_CONFIG; then
            _LOG "Could not write proxy config" "error"
            return 1
        fi
    fi
}

_UPDATE_BUSY_LIST()
{
    local _SPACE_NAME="_UPDATE_BUSY_LIST"

    local newList=""
    local tuple=
    for tuple in ${_BUSYLIST}; do
        local nakedFile="${tuple%%,*}"
        local pid="${tuple##*,}"
        # Check if the process is still alive.
        if kill -0 "${pid}" 2>/dev/null; then
            newList="${newList}${newList:+ }${nakedFile},${pid}"
        else
            # The process ended, check if the state is stopped or removed,
            # if so then remove any ramdisks this process has created.
            _LOG "Process exited for ${nakedFile} with PID ${pid}" "debug"
            if [ "$(id -u)" = "0" ]; then
                local stateFile="${nakedFile}.state"
                local state="$(cat "${stateFile}")"
                if [ "${state}" != "running" ]; then
                    local podDir="${nakedFile%/*}"
                    _DESTROY_RAMDISKS "${podDir}"
                fi
            fi
        fi
    done
    _BUSYLIST="${newList}"
}

_TRAP_TERM()
{
    local _SPACE_NAME="_TRAP_TERM"
    _PHASE="shutdown"
}

FILE_STAT()
{
    local _SPACE_NAME="FILE_STAT"

    local file="${1}"
    shift

    local format="${1}"
    shift

    #
    # Check for BSD stat
    if command -v "pkg" >/dev/null || command -v "brew" >/dev/null ; then
        # Translate format options
        format=$(printf "%s" "${format}" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f "${format}" "${file}"
    else
        stat -c "${format}" "${file}"
    fi

    if [ "$?" -gt 0 ]; then
        PRINT "Failed to stat file: ${file}." "error"
        return 1
    fi
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

_FETCH_POD_FILES()
{
    local _SPACE_NAME="_FETCH_POD_FILES"
    local tuple=
    for tuple in ${_PODPATTERNS}; do
        local basedir="${tuple%%,*}"
        local pattern="${tuple##*,}"
        local stateFiles=
        if ! stateFiles="$(find "${basedir}" -regex "${pattern}" 2>/dev/null)"; then
            return 1
        fi
        local stateFile=
        _PODS=""
        for stateFile in ${stateFiles}; do
            local nakedFile="${stateFile%.state}"
            # Check so that the state file has a pod buddie file,
            # if so store it.
            if [ -f "${nakedFile}" ]; then
                _PODS="${_PODS}${_PODS:+ }${nakedFile}"
            fi
        done
    done
}

_CHECK_CONFIG_CHANGES()
{
    local _SPACE_NAME="_CHECK_CONFIG_CHANGES"

    local changedList=""
    local newList=""

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local configsDir="${podDir}/config"
        if [ ! -d "${podDir}" ]; then
            continue
        fi

        local isBusy=0
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list.
                isBusy=1
                break
            fi
        done

        # Get the checksum of each config dir in the pod dir.
        local configDir=
        for configDir in ${configsDir}/*; do
            if [ ! -d "${configDir}" ]; then
                continue
            fi

            # Get previous checksum, if any
            local chksumPrevious=
            local index=
            if STRING_ITEM_INDEXOF "${_CONFIGCHKSUMS}" "${configDir}" "index"; then
                STRING_ITEM_GET "${_CONFIGCHKSUMS}" "$((index+1))" "chksumPrevious"
            fi

            # If this pod is in busy list, just transfer the previous checksum over,
            # because if config has changed we don't want to burn that notification already.
            if [ "${isBusy}" = "1" ]; then
                newList="${newList}${newList:+ }${configDir} ${chksumPrevious}"
                continue
            fi

            local chksum=
            if ! chksum=$(FILE_DIR_CHECKSUM "${configDir}"); then
                return 1
            fi

            if ! [ "${chksum}" = "${chksumPrevious}" ]; then
                # Mismatch, store it in changed list, unless this was the first time
                if [ -n "${chksumPrevious}" ]; then
                    changedList="${changedList}${changedList:+ }${configDir}"
                fi
            fi
            newList="${newList}${newList:+ }${configDir} ${chksum}"
        done
    done

    _CONFIGCHKSUMS="${newList}"
    _CONFIGSCHANGED="${changedList}"
}

_SPAWN_PROCESSES()
{
    local _SPACE_NAME="_SPAWN_PROCESSES"

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list.
                continue 2
            fi
        done

        local stateFile="${nakedFile}.state"
        local state="$(cat "${stateFile}")"
        local changedConfigs=""
        if [ "${state}" = "running" ]; then
            # Check for changed configs
            local configDir=
            for configDir in ${_CONFIGSCHANGED}; do
                # Check if this config dir is for the current pod
                local config="${configDir##${podDir}/config/}"
                if [ "${config}" != "${configDir}" ]; then
                    changedConfigs="${changedConfigs}${changedConfigs:+ }${config}"
                fi
            done
        fi

        # Note: we could do an optimization where we don't spawn
        # a process for a pod which should be stopped and which
        # we have already stopped.
        # It is enough to only run pods which need to be constantly
        # checked on to be in the running state.

        if ! _SPAWN_PROCESS "${nakedFile}" "${state}" "${changedConfigs}"; then
            _LOG "Could not spawn process for ${nakedFile}" "error" "spawn:${nakedFile}"
            return 0
        fi
    done
}

_WRITE_PROXY_CONFIG()
{
    local _SPACE_NAME="_WRITE_PROXY_CONFIG"
    if [ -z "${_PROXYCONF}" ]; then
        return 0
    fi

    local proxyConf="${_TMPDIR}/proxy.conf"

    local file=
    local contents=
    cat "${_TMPDIR}"/proxy.*.conf 2>/dev/null |sort >"${proxyConf}"
    printf "%s\\n" "### EOF" >>"${proxyConf}"

    if diff "${_PROXYCONF}" "${proxyConf}" >/dev/null 2>&1; then
        return 0
    fi

    cp "${proxyConf}" "${_PROXYCONF}"
}

_DESTROY_RAMDISKS()
{
    local _SPACE_NAME="_DESTROY_RAMDISKS"

    if [ -d "${podDir}/ramdisk" ]; then
        local dir=
        for dir in "${podDir}/ramdisk/"*; do
            if mountpoint -q "${dir}"; then
                _LOG "Unmount ramdisk ${dir}" "info"
                umount "${dir}"
            fi
        done
    fi
}

FILE_DIR_CHECKSUM()
{
    local _SPACE_NAME="FILE_DIR_CHECKSUM"

    local dir="${1}"
    shift

    local _SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        _SHASUMBIN=sha256sum
    elif command -v sha1sum >/dev/null; then
        _SHASUMBIN=sha1sum
    elif command -v shasum >/dev/null; then
        _SHASUMBIN="shasum -a 256"
    elif command -v md5sum >/dev/null; then
        _SHASUMBIN="md5sum"
    else
        return 1
    fi

    (cd "${dir}" && ls -lAR "." |${_SHASUMBIN} |cut -f 1 -d' ')
}

_SPAWN_PROCESS()
{
    local _SPACE_NAME="_SPAWN_PROCESS"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local changedConfigs="${1}"
    shift

    local podFile="${nakedFile}"

    local exec="sh -c"
    if [ "$(id -u)" = "0" ]; then
        # Drop priviligies
        exec="su ${_USER} -c"
    fi

    local command=

    if [ "${state}" = "running" ]; then
        command="run"
        if [ "$(id -u)" = "0" ]; then
            # Check if to create ramdisks for this pod
            local ramdisks=
            ramdisks="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ramdisk-config")"
            if [ -n "${ramdisks}" ]; then
                local podDir="${nakedFile%/*}"
                local ramdisk=
                for ramdisk in ${ramdisks}; do
                    local name="${ramdisk%:*}"
                    local size="${ramdisk#*:}"
                    local error=
                    if ! error="$(_CREATE_RAMDISK "${podDir}" "${name}" "${size}" 2>&1)"; then
                        _LOG "Could not create ramdisk ${name}:${size} in ${podDir}, Error: ${error}" "error" "ramdisk:${podDir}:${name}:${size}"
                    else
                        _LOG "Created ramdisk ${name}:${size} in ${podDir}" "info" "ramdisk:${podDir}:${name}:${size}"
                        return 1
                    fi
                done
            fi
        fi
    elif [ "${state}" = "stopped" ]; then
        command="stop"
    elif [ "${state}" = "removed" ]; then
        command="rm"
    else
        LOG "State file has unknown state." "debug"
        return 0
    fi

    local hash=
    if ! STRING_HASH "${nakedFile}" "hash"; then
        return 1
    fi

    local proxyConfigFragment="${_TMPDIR}/proxy.${hash}.conf"

    local pid=
    (
        local error=
        # If running as root we will drop privileges here.
        if ! error="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ${command}" 2>&1)"; then
            _LOG "Could not exec ${podFile} ${command}. Error: ${error}" "error" "exec:${podFile}:${command}"
        else
            _LOG "Exec ${podFile} ${command}" "info" "exec:${podFile}:${command}"
        fi
        if [ -n "${changedConfigs}" ]; then
            if ! error="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} reload-configs ${changedConfigs}" 2>&1)"; then
                _LOG "Could not exec ${podFile} reload-configs. Error: ${error}" "error" "exec:${podFile}:reload-configs"
            else
                _LOG "Exec ${podFile} reload-configs" "info" "exec:${podFile}:reload-configs"
            fi
        fi

        # We mute stderr for the remaining ${exec} invocations by setting: SPACE_LOG_LEVEL="0"
        if [ "${state}" = "running" ]; then
            local cc=
            if [ -f "${podFile}.proxy.conf" ]; then
                cc="$(cat "${podFile}.proxy.conf")"
            fi
            if [ -n "${cc}" ]; then
                # Run ReadinessProbe and write proxy config fragment.
                if SPACE_LOG_LEVEL="0" ${exec} "${podFile} readiness"; then
                    printf "%s\\n" "${cc}" >"${proxyConfigFragment}.tmp"
                else
                    # Reset
                    printf "# Not ready: %s\\n" "${podFile}" >"${proxyConfigFragment}.tmp"
                fi
                mv -f "${proxyConfigFragment}.tmp" "${proxyConfigFragment}"
            fi

            # Run LivenessProbe
            SPACE_LOG_LEVEL="0" ${exec} "${podFile} liveness"
        fi
    )&
    pid=$!

    _BUSYLIST="${_BUSYLIST}${_BUSYLIST:+ }${nakedFile},${pid}"
}

_CREATE_RAMDISK()
{
    local _SPACE_NAME="_CREATE_RAMDISK"

    if [ ! -d "${podDir}/ramdisk" ]; then
        mkdir "${podDir}/ramdisk"
        chown "${_USER}:${_USER}" "${podDir}/ramdisk"
    fi

    if [ ! -d "${podDir}/ramdisk/${name}" ]; then
        mkdir "${podDir}/ramdisk/${name}"
        chown "${_USER}:${_USER}" "${podDir}/ramdisk/${name}"
    fi

    if mountpoint -q "${podDir}/ramdisk/${name}"; then
        # Already exists.
        return 0
    fi

    if ! mount -t tmpfs -o size="${size}" tmpfs "${podDir}/ramdisk/${name}"; then
        return 1
    fi

    chown "${_USER}:${_USER}" "${podDir}/ramdisk/${name}"
    chmod 700 "${podDir}/ramdisk/${name}"
}

main()
{
    DAEMON_MAIN "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /run/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /run/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
