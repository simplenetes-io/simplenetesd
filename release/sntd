#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.4.0 | https://space.sh
#
# Node: /cmdline/
# Use sntd as a standalone cmd line tool

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
SNTD_CMDLINE()
{
    local _SPACE_NAME="SNTD_CMDLINE"

    local _out_rest=""
    local _out_h="false"
    local _out_V="false"

    if ! _GETOPTS "h V" "" 0 1 "$@"; then
        printf "Usage: sntd [clusterHome]  [-o logfile] \\n" >&2
        return 1
    fi

    if [ "${_out_h}" = "true" ]; then
        USAGE
        return
    fi

    if [ "${_out_V}" = "true" ]; then
        VERSION
        return
    fi

    DAEMON_MAIN "${_out_rest}"
}

USAGE()
{
    local _SPACE_NAME="USAGE"
    printf "%s\\n" "Usage:

    sntd -h
        Output this help

    sntd -V
        Output version

    sntd [hosthome]

        hosthome (optional)
            Path to directory of the cluster root directory.
            If provided the program will run pods only for that cluster project,
            if the process is run as root then ramdisks will be available.

            If the hosthome argument is left out then the process must be run as root and it
            will then search for cluster directories for all users and manage the lifecycles
            for all the cluster projects on the host.

" >&2
}

VERSION()
{
    local _SPACE_NAME="VERSION"
    printf "%s\\n" "Simplenetes daemon version 0.1."
}

DAEMON_MAIN()
{
    local _SPACE_NAME="DAEMON_MAIN"

    local hostHome="${1:-}"

    # If not root and no dir given then exit.
    if [ "$(id -u)" != 0 ]; then
        if [ -z "${hostHome}" ]; then
            PRINT "The daemon has to be run as root, unless it is meant to be run for a single cluster project then provide the HOSTHOME dir as first argument" "error" 0
            return 1
        fi
    fi

    local _EXIT=0
    local main_pids=""
    trap _TRAP_TERM_MAIN TERM INT HUP

    # If directory given as argument then don't run this in Daemon mode,
    # pass it directly to _DAEMON_RUN to run for single user.
    # Regardless if running as root or not.
    if [ -n "${hostHome}" ]; then
        # Run for single user
        hostHome="$(FILE_REALPATH "${hostHome}")"
        if [ ! -d "${hostHome}/pods" ]; then
            PRINT "The specified hostHome '${hostHome}' is lacking a 'pods' dir" "error" 0
            return 1
        fi
        PRINT "Running service for single host home. PID: $$" "info" 0
        PRINT "Adding watch to ${hostHome}" "info" 0
        local pid=
        _DAEMON_RUN "${hostHome}" &
        pid=$!
        main_pids="${main_pids}${main_pids:+ }${pid}"

        # Wait until signalled to exit.
        while [ "${_EXIT}" -eq 0 ]; do
            sleep 1
        done
    else
        PRINT "Running service for all users. PID: $$" "info" 0

        local clustersDone=""

        while [ "${_EXIT}" -eq 0 ]; do
            local file=
            for file in $(find /home -mindepth 3 -maxdepth 3 -type f -name cluster-id.txt); do
                local hostHome="${file%/*}"
                if [ ! -d "${hostHome}/pods" ]; then
                    continue
                fi
                # Check if we already have this cluster.
                if STRING_ITEM_INDEXOF "${clustersDone}" "${hostHome}"; then
                    continue
                fi

                clustersDone="${clustersDone}${clustersDone:+ }${hostHome}"
                PRINT "Adding watch to ${hostHome}" "info" 0

                local pid=
                _DAEMON_RUN "${hostHome}" &
                pid=$!
                main_pids="${main_pids}${main_pids:+ }${pid}"
            done
            sleep 3
        done
    fi

    trap - TERM INT HUP

    # Kill subprocesses, if not already killed.
    local pid=
    for pid in ${main_pids}; do
        kill -s HUP "${pid}" 2>/dev/null
    done

    # Wait for sub processes to exit
    wait ${main_pids} 2>/dev/null >&2

    # Set the exit status to error if this was not a user triggered shutdown.
    [ "${_EXIT}" -eq 1 ]
    return
}

_GETOPTS()
{
    local _SPACE_NAME="_GETOPTS"

    local simpleSwitches="${1}"
    shift

    local richSwitches="${1}"
    shift

    local minPositional="${1:-0}"
    shift

    local maxPositional="${1:-0}"
    shift

    _out_rest=""

    local options=""
    local option=
    for option in ${richSwitches}; do
        options="${options}${option}:"
    done

    local posCount="0"
    while [ "$#" -gt 0 ]; do
        local flag="${1#-}"
        if [ "${flag}" = "${1}" ]; then
            # Non switch
            posCount="$((posCount+1))"
            if [ "${posCount}" -gt "${maxPositional}" ]; then
                PRINT "Too many positional argumets, max ${maxPositional}" "error" 0
                return 1
            fi
            _out_rest="${_out_rest}${_out_rest:+ }${1}"
            shift
            continue
        fi
        local flag2=
        STRING_SUBSTR "${flag}" 0 1 "flag2"
        if STRING_ITEM_INDEXOF "${simpleSwitches}" "${flag2}"; then
            if [ "${#flag}" -gt 1 ]; then
                PRINT "Invalid option: -${flag}" "error" 0
                return 1
            fi
            eval "_out_${flag}=\"true\""
            shift
            continue
        fi

        local OPTIND=1
        getopts ":${options}" "flag"
        case "${flag}" in
            \?)
                PRINT "Unknown option ${1-}" "error" 0
                return 1
                ;;
            :)
                PRINT "Option -${OPTARG-} requires an argument" "error" 0
                return 1
                ;;
            *)
                STRING_ESCAPE "OPTARG"
                eval "_out_${flag}=\"${OPTARG}\""
                ;;
        esac
        shift $((OPTIND-1))
    done

    if [ "${posCount}" -lt "${minPositional}" ]; then
        PRINT "Too few positional argumets, min ${minPositional}" "error" 0
        return 1
    fi
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

_DAEMON_RUN()
{
    local _SPACE_NAME="_DAEMON_RUN"

    local hostHome="${1}"
    shift

    # Declaring some shared variables here:
    local _USER=
    if ! _USER="$(FILE_STAT "${hostHome}" "%U")"; then
        PRINT "Could not stat owner of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi
    local _USERUID=
    if ! _USERUID="$(FILE_STAT "${hostHome}" "%u")"; then
        PRINT "Could not stat owner of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi

    local _USERGID=
    if ! _USERGID="$(FILE_STAT "${hostHome}" "%g")"; then
        PRINT "Could not stat owner group of directory ${hostHome}, will not run this instance" "error" 0
        return 1
    fi

    local _PODPATTERNS="${hostHome}/pods,.*/release/[^.].*/.*.state"
    local _PROXYCONF="${hostHome}/portmappings.conf"
    local _SUBPROCESS_LOG_LEVEL="${SPACE_LOG_LEVEL:-2}"  # The SPACE_LOG_LEVEL of the subprocesses pod scripts.
    local _BUSYLIST=""
    local _PODS=""
    local _CURRENT_STATES=""

    local _PHASE="normal"

    # Bash needs INT to be ignored in subprocesses.
    trap '' INT

    trap _TRAP_TERM HUP

    while [ "${_PHASE}" = "normal" ]; do
        if ! _DAEMON_ITERATE; then
            _PHASE="shutdown"
            continue
        fi
        sleep 6
    done

    trap - HUP

    # Perform graceful shutdown.
    # Wait for all subprocesses to exit.
    PRINT "Initiating graceful shutdown for ${hostHome}" "info" 0
    while [ -n "${_BUSYLIST}" ]; do
        _UPDATE_BUSY_LIST
        sleep 2
    done

    PRINT "Shutdown done for ${hostHome}" "info" 0
}

_TRAP_TERM_MAIN()
{
    local _SPACE_NAME="_TRAP_TERM_MAIN"
    _EXIT=1
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"
    shift

    local pwd="${1:-$PWD}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${pwd}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

STRING_SUBSTR()
{
    local _SPACE_NAME="STRING_SUBSTR"

    # shellcheck disable=SC2034
    local __sopriv="${1}"
    shift

    local __index="${1}"
    shift

    local __length="${1}"
    shift

    local __outvar="${1:-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __strlength="${#__sopriv}"

    if [ "${__index}" -lt 0 ]; then
        __index=$((__strlength+__index))
    fi

    if [ "${__index}" -ge 0 ]; then
        if [ "${__length}" = "" ]; then
            __length=$((__strlength-__index))
        fi

        if [ "${__length}" -lt 0 ]; then
            __length=$((__strlength-__index+__length))
        fi

        if [ "$((__index+__length))" -le "${#__sopriv}" ]; then
            local __wildcard=
            STRING_REPEAT "?" "${__index}" "" "__wildcard"
            local __substr="${__sopriv#${__wildcard}}"
            STRING_REPEAT "?" "$((${#__substr}-__length))" "" "__wildcard"
            __substr="${__substr%${__wildcard}}"
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__substr}\""
            else
                printf "%s\\n" "${__outvar}"
            fi
            return 0
        fi

    fi

    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"\""
    fi
}

STRING_INDEXOF()
{
    local _SPACE_NAME="STRING_INDEXOF"

    local substr="${1}"
    shift

    local string="${1}"
    shift

    local varname="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local rest="${string%%${substr}*}"

    if [ "${rest}" = "${string}" ]; then
        if [ -n "${varname}" ]; then
            eval "${varname}=\"-1\""
        fi
        return 1
    fi

    if [ -n "${varname}" ]; then
        eval "${varname}=\"${#rest}\""
    fi
    return 0
}

STRING_ESCAPE()
{
    local _SPACE_NAME="STRING_ESCAPE"

    local ___char=
    for ___char in \" \$ \( \) \< \> \| \& \/; do
        case "${2-\"\$}" in
            *${___char}*)
                _STRING_ESCAPE "${1}" "${___char}"
                ;;
        esac
    done
}

_DAEMON_ITERATE()
{
    local _SPACE_NAME="_DAEMON_ITERATE"

    if ! _FETCH_POD_FILES; then
        PRINT "Error in fetching pod files" "error" 0
        return 1
    fi

    if ! _UPDATE_BUSY_LIST; then
        PRINT "Cannot update busy list" "error" 0
        return 1
    fi

    if ! _SPAWN_PROCESSES; then
       PRINT "Could not spawn process" "error" 0
        return 1
    fi

    if ! _WRITE_PROXY_CONFIG; then
        PRINT "Could not write proxy config" "error" 0
        return 1
    fi
}

_UPDATE_BUSY_LIST()
{
    local _SPACE_NAME="_UPDATE_BUSY_LIST"

    local newList=""
    local tuple=
    for tuple in ${_BUSYLIST}; do
        local nakedFile="${tuple%%,*}"
        local pid="${tuple##*,}"
        # Check if the process is still alive.
        if kill -0 "${pid}" 2>/dev/null; then
            newList="${newList}${newList:+ }${nakedFile},${pid}"
        else
            # The process ended, check if it should be running and exit code was > 0, then put it back for retry.
            # Otherwise if the state is not "running" remove any ramdisks this process has created.
            # Get exit code
            local exitCode=
            wait "${pid}"
            exitCode="$?"
            PRINT "Spawn process exited for ${nakedFile} with PID ${pid}, exit code: ${exitCode}." "debug" 0
            local stateFile="${nakedFile}.state"
            local state="$(cat "${stateFile}")"
            if [ "${state}" = "running" ]; then
                if [ "${exitCode}" -gt 0 ]; then
                    # Retry running this.
                    PRINT "Retry running ${nakedFile}" "info" 0
                    local actionFile="${nakedFile}.action"
                    printf "%s\\n" "rerun" >"${actionFile}"
                fi
            else
                # Remove ramdisks, if sntd running as root.
                if [ "$(id -u)" = "0" ]; then
                    local podDir="${nakedFile%/*}"
                    _DESTROY_RAMDISKS "${podDir}"
                fi
            fi
        fi
    done
    _BUSYLIST="${newList}"
}

_TRAP_TERM()
{
    local _SPACE_NAME="_TRAP_TERM"
    _PHASE="shutdown"
}

FILE_STAT()
{
    local _SPACE_NAME="FILE_STAT"

    local file="${1}"
    shift

    local format="${1}"
    shift

    #
    # Check for BSD stat
    if command -v "pkg" >/dev/null || command -v "brew" >/dev/null ; then
        # Translate format options
        format=$(printf "%s" "${format}" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f "${format}" "${file}"
    else
        stat -c "${format}" "${file}"
    fi

    if [ "$?" -gt 0 ]; then
        PRINT "Failed to stat file: ${file}." "error"
        return 1
    fi
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

STRING_REPEAT()
{
    local _SPACE_NAME="STRING_REPEAT"

    local __string="${1}"
    shift

    local __count="${1}"
    shift

    local __separator="${1}"
    shift

    local __outvar="${1}"
    shift

    local __repeatedstring=""
    while [ "${__count}" -gt 0 ]; do
        __count=$((__count-1))
        __repeatedstring="${__repeatedstring}${__string}"
        if [ "${__count}" -gt 0 ]; then
            __repeatedstring="${__repeatedstring}${__separator}"
        fi
    done

    eval "${__outvar}=\"\${__repeatedstring}\""
}

_STRING_ESCAPE()
{
    local _SPACE_NAME="_STRING_ESCAPE"
    local __right=
    local __result=""
    eval "__right=\$${1}"
    local __left=
    while true; do
        # Cut from right up until last occurrence of char.
        __left="${__right%%${2}*}"
        if [ "${__left}" = "${__right}" ]; then
            # Done
            __result="${__result}${__left}"
            break
        fi
        __right="${__right#$__left}"
        # This seems to be necessary the remove the escapes properly.
        __right="${__right#*${2}}"
        # Now cut away from right all escapes, one by one..
        local __escapes=""
        local __left2=
        while true; do
            __left2="${__left%[\\]}"
            if [ "${__left2}" = "${__left}" ]; then
                # No more escapes
                break
            fi
            # Escape encountered
            __escapes="${__escapes}\\"
            __left="${__left2}"
        done
        # Double the number of escapes and add one.
        __result="${__result}${__left}${__escapes}${__escapes}\\${2}"
    done
    eval "${1}=\${__result}"
}

_FETCH_POD_FILES()
{
    local _SPACE_NAME="_FETCH_POD_FILES"
    local tuple=
    for tuple in ${_PODPATTERNS}; do
        local basedir="${tuple%%,*}"
        local pattern="${tuple##*,}"
        local stateFiles=
        if ! stateFiles="$(find "${basedir}" -regex "${pattern}" 2>/dev/null)"; then
            return 1
        fi
        local stateFile=
        _PODS=""
        for stateFile in ${stateFiles}; do
            local nakedFile="${stateFile%.state}"
            # Check so that the state file has a pod buddie file,
            # if so store it.
            if [ -f "${nakedFile}" ]; then
                _PODS="${_PODS}${_PODS:+ }${nakedFile}"
            fi
        done
    done
}

_SPAWN_PROCESSES()
{
    local _SPACE_NAME="_SPAWN_PROCESSES"

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list, skip for now
                continue 2
            fi
        done

        local actionFile="${nakedFile}.action"
        local action=
        if [ -f "${actionFile}" ]; then
            action="$(cat "${actionFile}")"
            rm "${actionFile}"
            # Check the action so it is valid:
            if [ "${action%[ ]*}" = "rerun" ]; then
                if ! STRING_IS_ALL "${action}" "a-z0-9_ "; then
                    action=
                fi
            else
                action=
            fi
            if [ -z "${action}" ]; then
                PRINT "Action not recognized for ${nakedFile}" "error" 0
            fi
        fi

        local stateFile="${nakedFile}.state"
        local state="$(cat "${stateFile}")"
        local stateChanged="false"

        if _SPAWN_STATE_CHANGED "${nakedFile}" "${state}"; then
            stateChanged="true"
            PRINT "State changed. Exec ${nakedFile} ${state}" "info" 0
        fi

        if [ "${stateChanged}" = "true" ] && [ -n "${action}" ]; then
            PRINT "Action '${action}' provided but pod state did also change, so ignoring action. For ${nakedFile}" "warning" 0
            action=""
        fi

        if [ "${state}" = "running" ]; then
            if [ -n "${action}" ]; then
                PRINT "Action '${action}' provided for ${nakedFile}" "info" 0
            fi
        else
            if [ -n "${action}" ]; then
                PRINT "Action '${action}' provided but pod is not in 'running' state for ${nakedFile}" "warning" 0
                # Do not perform actions on non running containers
                action=""
            fi
        fi

        if [ "${stateChanged}" = "true" ] ||
           [ -n "${action}" ]; then
            if ! _SPAWN_PROCESS "${nakedFile}" "${state}" "${action}"; then
                PRINT "Could not spawn process for ${nakedFile}" "error" 0
                return 0
            fi
        fi
    done
}

_WRITE_PROXY_CONFIG()
{
    local _SPACE_NAME="_WRITE_PROXY_CONFIG"
    if [ -z "${_PROXYCONF}" ]; then
        return 0
    fi

    local nl="
"
    local contents=""
    local nakedFile=
    for nakedFile in ${_PODS}; do
        # Check so state is running
        local stateFile="${nakedFile}.state"
        if [ ! -f "${stateFile}" ]; then
            continue
        fi
        local state="$(cat "${stateFile}")"
        if [ "${state}" != "running" ]; then
            continue
        fi

        # Check readiness
        local proxyFile="${nakedFile}.portmappings.conf"
        # Make into dotfile
        proxyFile="${proxyFile%/*}/.${proxyFile##*/}"

        local statusFile="${nakedFile}.status"
        if [ ! -f "${statusFile}" ]; then
            continue
        fi
        local readiness="$(grep "^readiness:" "${statusFile}" |cut -d' ' -f2)"
        if [ "${readiness}" = "1" ]; then
            # Check that last update time is not too old
            local updated="$(grep "^updated:" "${statusFile}" |cut -d' ' -f2)"
            if [ -n "${updated}" ]; then
                local ts="$(date +%s)"
                # Allow a maximum 10 minutes old update.
                if [ $((ts-updated > 600)) -eq 1 ]; then
                    continue
                fi
            fi
            if [ -f "${proxyFile}" ]; then
                contents="${contents}${contents:+ $nl}$(cat "${proxyFile}")"
            fi
        fi
    done

    local proxyConf="$(mktemp 2>/dev/null || mktemp -t 'sometmpdir')"

    printf "%s\\n" "${contents}" |sort >"${proxyConf}"

    if diff "${_PROXYCONF}" "${proxyConf}" >/dev/null 2>&1; then
        rm "${proxyConf}"
        return 0
    fi

    mv -f "${proxyConf}" "${_PROXYCONF}"
}

_DESTROY_RAMDISKS()
{
    local _SPACE_NAME="_DESTROY_RAMDISKS"

    if [ -d "${podDir}/ramdisk" ]; then
        local dir=
        for dir in $(find "${podDir}/ramdisk" -maxdepth 1 -mindepth 1 -type d 2>/dev/null); do
            if mountpoint -q "${dir}"; then
                PRINT "Unmount ramdisk ${dir}" "info" 0
                umount "${dir}"
            fi
        done
    fi
}

_SPAWN_PROCESS()
{
    local _SPACE_NAME="_SPAWN_PROCESS"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local action="${1}"
    shift

    local podFile="${nakedFile}"

    local _HOME="${HOME}"
    local exec="sh -c"
    if [ "$(id -u)" = "0" ]; then
        # Drop priviligies
        exec="setpriv --reuid ${_USERUID} --regid ${_USERGID} --init-groups sh -c"
        _HOME="/home/${_USER}"
    fi

    local command=

    # If we have an action given, then we hijack the command at this point.
    if [ -n "${action}" ]; then
        command="${action}"
    elif [ "${state}" = "running" ]; then
        command="run"
        if [ "$(id -u)" = "0" ]; then
            # Check if to create ramdisks for this pod
            # Note: instead of running `pod create-ramdisks` as root and have it done with,
            # we drop privileges and get the ramdisk config. This is a security consideration
            # because we don't want to run any user provided pod code as root.
            local ramdisks=
            ramdisks="$(USER="${_USER}" HOME="${_HOME}" SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} create-ramdisks -l")"
            if [ -n "${ramdisks}" ]; then
                local podDir="${nakedFile%/*}"
                local ramdisk=
                for ramdisk in ${ramdisks}; do
                    local name="${ramdisk%:*}"
                    local size="${ramdisk#*:}"
                    local error=
                    if ! error="$(_CREATE_RAMDISK "${podDir}" "${name}" "${size}" 2>&1)"; then
                        PRINT "Could not create ramdisk ${name}:${size} in ${podDir}, Error: ${error}" "error" 0
                        return 1
                    else
                        PRINT "Created ramdisk ${name}:${size} in ${podDir}" "info" 0
                    fi
                done
            fi
        fi
    elif [ "${state}" = "stopped" ]; then
        command="stop"
    elif [ "${state}" = "removed" ]; then
        command="rm"
    else
        PRINT "State file has unknown state." "debug" 0
        return 0
    fi

    local hash=
    if ! STRING_HASH "${nakedFile}" "hash"; then
        return 1
    fi

    local pid=
    (
        local error=
        local exitCode=
        # If running as root we will drop privileges here, thanks to ${exec}.
        error="$(USER="${_USER}" HOME="${_HOME}" SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ${command}" 2>&1)"
        exitCode="$?"
        if [ "${exitCode}" -gt 0 ]; then
            PRINT "Could not exec ${podFile} ${command}. Exit code: ${exitCode}. Error: ${error}" "error" 0
            return "${exitCode}"
        fi
    )&
    pid=$!

    _BUSYLIST="${_BUSYLIST}${_BUSYLIST:+ }${nakedFile},${pid}"
}

_SPAWN_STATE_CHANGED()
{
    local _SPACE_NAME="_SPAWN_STATE_CHANGED"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local prevState=""
    local line="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -m1 "^${nakedFile} ")"

    if [ -n "${line}" ]; then
        prevState="${line##*[ ]}"
        _CURRENT_STATES="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -v "^${nakedFile} ")"
    fi

    # Save state
    local nl="
"
    _CURRENT_STATES="${_CURRENT_STATES}${_CURRENT_STATES:+$nl}${nakedFile} ${state}"

    # Set return status
    [ "${prevState}" != "${state}" ]
}

STRING_IS_ALL()
{
    local _SPACE_NAME="STRING_IS_ALL"

    local __str="${1}"
    shift

    local __pattern="${1}"
    shift

    local __m="[!${__pattern}]"
    case "${__str}" in
        (*${__m}*)
            return 1
            ;;
        *)
            ;;
    esac
}

STRING_HASH()
{
    local _SPACE_NAME="STRING_HASH"

    local __str="${1}"
    shift

    local __outvar="${1}"
    shift

    local SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        SHASUMBIN="sha256sum"
    elif command -v shasum >/dev/null; then
        SHASUMBIN="shasum -a 256"
    fi

    if [ -z "${SHASUMBIN}" ]; then
        return 1
    fi

    local __hash=
    __hash=$(printf "%s\\n" "${__str}" |${SHASUMBIN}) || { return 1; }
    __hash="${__hash%%[ ]*}"
    eval "${__outvar}=\"\${__hash}\""
}

_CREATE_RAMDISK()
{
    local _SPACE_NAME="_CREATE_RAMDISK"

    if [ ! -d "${podDir}/ramdisk" ]; then
        mkdir "${podDir}/ramdisk"
        chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk"
    fi

    if [ ! -d "${podDir}/ramdisk/${name}" ]; then
        mkdir "${podDir}/ramdisk/${name}"
        chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk/${name}"
    fi

    if mountpoint -q "${podDir}/ramdisk/${name}"; then
        # Already exists.
        return 0
    fi

    # If the pod was run without daemon prior and it created "fake" ramdisks which might be lingering from an abrupt shutdown,
    # that is fine, since a mount will shadow the existing directory contents.

    if ! mount -t tmpfs -o size="${size}" tmpfs "${podDir}/ramdisk/${name}"; then
        return 1
    fi

    chown "${_USERUID}:${_USERGID}" "${podDir}/ramdisk/${name}"
    chmod 700 "${podDir}/ramdisk/${name}"
}

main()
{
    SNTD_CMDLINE "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /cmdline/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /cmdline/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
