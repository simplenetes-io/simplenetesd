#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /cmdline/
# Use sntd as a standalone cmd line tool

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
SNTD_CMDLINE()
{
    local _SPACE_NAME="SNTD_CMDLINE"

    local _out_rest=""
    local _out_h="false"
    local _out_V="false"

    local _out_o=""

    if ! _GETOPTS "h V" "o" 0 1 "$@"; then
        printf "Usage: sntd [clusterHome]  [-o logfile] \\n" >&2
        return 1
    fi

    if [ "${_out_h}" = "true" ]; then
        USAGE
        return
    fi

    if [ "${_out_V}" = "true" ]; then
        VERSION
        return
    fi

    local logfile="${_out_o}"

    if [ -n "${logfile}" ]; then
        DAEMON_MAIN "${_out_rest}" 2>>"${logfile}"
    else
        DAEMON_MAIN "${_out_rest}"
    fi
}

USAGE()
{
    local _SPACE_NAME="USAGE"
    printf "%s\\n" "Usage:

    sntd -h
        Output this help

    sntd -V
        Output version

    sntd [hosthome] [-o logfile]

        hosthome (optional)
            Path to directory of the cluster root directory.
            If provided the program will run pods only for that cluster project,
            if the process is run as root then ramdisks will be available.

            If the hosthome argument is left out then the process must be run as root and it
            will then search for cluster directories for all users and manage the lifecycles
            for all the cluster projects on the host.

        -o logfile
            Path to logfile to append output.
            In left out then output to stderr.


" >&2
}

VERSION()
{
    local _SPACE_NAME="VERSION"
    printf "%s\\n" "Simplenetes daemon version 0.1."
}

DAEMON_MAIN()
{
    local _SPACE_NAME="DAEMON_MAIN"

    local hostHome="${1:-}"

    local _LOGFILETAGS="$(mktemp 2>/dev/null || mktemp -t 'sometmpdir')"

    # If not root and no dir given then exit.
    if [ $(id -u) != 0 ]; then
        if [ -z "${hostHome}" ]; then
            _LOG "The daemon has to be run as root, unless it is meant to be run for a single cluster project then provide the HOSTHOME dir as first argument" "fatal"
            return 1
        fi
    fi

    local _EXIT=0
    local main_pids=""
    trap _TRAP_TERM_MAIN TERM INT

    # If directory given as argument then don't run this in Daemon mode,
    # pass it directly to _DAEMON_RUN to run for single user.
    # Regardless if running as root or not.
    if [ -n "${hostHome}" ]; then
        # Run for single user
        hostHome="$(FILE_REALPATH "${hostHome}")"
        _LOG "hostHome is ${hostHome}" "info"
        if [ ! -d "${hostHome}/pods" ]; then
            _LOG "The specified hostHome is lacking a 'pods' dir" "fatal"
            return 1
        fi
        _LOG "Running for single user in foreground (dev mode). PID: $$" "info"
        _LOG "Adding watch to ${hostHome}" "info"
        local pid=
        _DAEMON_RUN "${hostHome}" &
        pid=$!
        main_pids="${main_pids}${main_pids:+ }${pid}"
        while true; do
            sleep 1
            # This loop will end if the single sub process exists.
            if kill -0 ${main_pids} 2>/dev/null && [ "${_EXIT}" -eq 0 ]; then
                continue
            fi
            # Wait for sub processes to exit
            wait ${main_pids} 2>/dev/null >&2
            break
        done

        # Set the exit status to error if this was not a user triggered shutdown.
        [ "${_EXIT}" -eq 1 ]
        return
    fi

    _LOG "Running as a system daemon for all users. PID: $$" "info"

    local clustersDone=""

    while [ "${_EXIT}" -eq 0 ]; do
        local file=
        for file in $(find /home -mindepth 3 -maxdepth 3 -type f -name cluster-id.txt); do
            local hostHome="${file%/*}"
            if [ ! -d "${hostHome}/pods" ]; then
                continue
            fi
            # Check if we already have this cluster.
            if STRING_ITEM_INDEXOF "${clustersDone}" "${hostHome}"; then
                continue
            fi

            clustersDone="${clustersDone}${clustersDone:+ }${hostHome}"
            _LOG "Adding watch to ${hostHome}" "info"

            local pid=
            _DAEMON_RUN "${hostHome}" &
            pid=$!
            main_pids="${main_pids}${main_pids:+ }${pid}"
        done
        sleep 3
    done

    # Wait for sub processes to exit
    wait ${main_pids} 2>/dev/null >&2
}

_GETOPTS()
{
    local _SPACE_NAME="_GETOPTS"

    local simpleSwitches="${1}"
    shift

    local richSwitches="${1}"
    shift

    local minPositional="${1:-0}"
    shift

    local maxPositional="${1:-0}"
    shift

    _out_rest=""

    local options=""
    local option=
    for option in ${richSwitches}; do
        options="${options}${option}:"
    done

    local posCount="0"
    while [ "$#" -gt 0 ]; do
        local flag="${1#-}"
        if [ "${flag}" = "${1}" ]; then
            # Non switch
            posCount="$((posCount+1))"
            if [ "${posCount}" -gt "${maxPositional}" ]; then
                PRINT "Too many positional argumets, max ${maxPositional}" "error" 0
                return 1
            fi
            _out_rest="${_out_rest}${_out_rest:+ }${1}"
            shift
            continue
        fi
        local flag2=
        STRING_SUBSTR "${flag}" 0 1 "flag2"
        if STRING_ITEM_INDEXOF "${simpleSwitches}" "${flag2}"; then
            if [ "${#flag}" -gt 1 ]; then
                PRINT "Invalid option: -${flag}" "error" 0
                return 1
            fi
            eval "_out_${flag}=\"true\""
            shift
            continue
        fi

        local OPTIND=1
        getopts ":${options}" "flag"
        case "${flag}" in
            \?)
                PRINT "Unknown option ${1-}" "error" 0
                return 1
                ;;
            :)
                PRINT "Option -${OPTARG-} requires an argument" "error" 0
                return 1
                ;;
            *)
                STRING_ESCAPE "OPTARG"
                eval "_out_${flag}=\"${OPTARG}\""
                ;;
        esac
        shift $((OPTIND-1))
    done

    if [ "${posCount}" -lt "${minPositional}" ]; then
        PRINT "Too few positional argumets, min ${minPositional}" "error" 0
        return 1
    fi
}

_LOG()
{
    local _SPACE_NAME="_LOG"

    local message="${1}"
    shift

    local level="${1}"
    shift

    # The tag can be used to have different formatted messages group together.
    # If no tag provided the message is the tag which means it won't repeat it self.
    local tag="${1:-${message}}"

    if [ "${tag}" = "0" ]; then
        PRINT "${message}" "${level}" 0
        return
    fi

    # Check if this tag already exists, of so check if the level is the same.
    local hash=
    STRING_HASH "${tag}" "hash"

    # Check if hash is present
    local row=
    local level2=
    if row="$(grep "^${hash}\>" "${_LOGFILETAGS}" 2>/dev/null)"; then
        level2="${row#*[ ]}"
    fi

    if [ "${level}" != "${level2}" ]; then
        local logtext="$(grep -v "^${hash}\>" "${_LOGFILETAGS}")"
        printf "%s\\n%s\\n" "${logtext}" "${hash} ${level}" >"${_LOGFILETAGS}"
        if [ "${level}" = "fatal" ]; then
            level="error"
        fi
        PRINT "${message}" "${level}" 0
    fi
}

_DAEMON_RUN()
{
    local _SPACE_NAME="_DAEMON_RUN"

    local hostHome="${1}"
    shift

    # Declaring some shared variables here:
    local _USER=
    if ! _USER="$(FILE_STAT "${hostHome}" "%U")"; then
        _LOG "Could not stat owner of directory ${hostHome}, will not run this instance" "error"
        return 1
    fi
    local _PODPATTERNS="${hostHome}/pods,.*/release/[^.].*/.*.state"
    local _PROXYCONF="${hostHome}/proxy.conf"
    local _SUBPROCESS_LOG_LEVEL="${SPACE_LOG_LEVEL:-2}"  # The SPACE_LOG_LEVEL of the subprocesses pod scripts.
    local _BUSYLIST=""
    local _PODS=""
    local _CONFIGCHKSUMS=""
    local _CONFIGSCHANGED=""
    local _TMPDIR=
    local _STARTTS="$(date +%s)"
    local _CURRENT_STATES=""

    # Global in this process:
    _PHASE="normal"

    trap _TRAP_TERM HUP

    while true; do
        if [ "${_PHASE}" = "normal" ]; then
            if ! _DAEMON_ITERATE; then
                _PHASE="shutdown"
                continue
            fi
            sleep 6
        elif [ "${_PHASE}" = "shutdown" ]; then
            # Perform graceful shutdown.
            # Wait for all subprocesses to exit.
            _LOG "Initiating graceful shutdown for ${hostHome}" "info"
            _UPDATE_BUSY_LIST
            if [ -z "${_BUSYLIST}" ]; then
                _LOG "Shutdown done for ${hostHome}" "info"
                return 1
            fi
            sleep 2
        fi
    done
}

_TRAP_TERM_MAIN()
{
    local _SPACE_NAME="_TRAP_TERM_MAIN"

    trap - TERM INT


    local pid=
    for pid in ${main_pids}; do
        _LOG "Kill off daemon process: ${pid}" "info"
        kill -s HUP "${pid}"
    done

    # This will trigger the loop to end.
    _EXIT=1
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"
    shift

    local pwd="${1:-$PWD}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${pwd}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME="STRING_SUBSTR"

    # shellcheck disable=SC2034
    local __sopriv="${1}"
    shift

    local __index="${1}"
    shift

    local __length="${1}"
    shift

    local __outvar="${1:-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __strlength="${#__sopriv}"

    if [ "${__index}" -lt 0 ]; then
        __index=$((__strlength+__index))
    fi

    if [ "${__index}" -ge 0 ]; then
        if [ "${__length}" = "" ]; then
            __length=$((__strlength-__index))
        fi

        if [ "${__length}" -lt 0 ]; then
            __length=$((__strlength-__index+__length))
        fi

        if [ "$((__index+__length))" -le "${#__sopriv}" ]; then
            local __wildcard=
            STRING_REPEAT "?" "${__index}" "" "__wildcard"
            local __substr="${__sopriv#${__wildcard}}"
            STRING_REPEAT "?" "$((${#__substr}-__length))" "" "__wildcard"
            __substr="${__substr%${__wildcard}}"
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__substr}\""
            else
                printf "%s\\n" "${__outvar}"
            fi
            return 0
        fi

    fi

    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"\""
    fi
}

STRING_INDEXOF()
{
    local _SPACE_NAME="STRING_INDEXOF"

    local substr="${1}"
    shift

    local string="${1}"
    shift

    local varname="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local rest="${string%%${substr}*}"

    if [ "${rest}" = "${string}" ]; then
        if [ -n "${varname}" ]; then
            eval "${varname}=\"-1\""
        fi
        return 1
    fi

    if [ -n "${varname}" ]; then
        eval "${varname}=\"${#rest}\""
    fi
    return 0
}

STRING_ESCAPE()
{
    local _SPACE_NAME="STRING_ESCAPE"

    local ___char=
    for ___char in \" \$ \( \) \< \> \| \& \/; do
        case "${2-\"\$}" in
            *${___char}*)
                _STRING_ESCAPE "${1}" "${___char}"
                ;;
        esac
    done
}

STRING_HASH()
{
    local _SPACE_NAME="STRING_HASH"

    local __str="${1}"
    shift

    local __outvar="${1}"
    shift

    local SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        SHASUMBIN="sha256sum"
    elif command -v shasum >/dev/null; then
        SHASUMBIN="shasum -a 256"
    fi

    if [ -z "${SHASUMBIN}" ]; then
        return 1
    fi

    local __hash=
    __hash=$(printf "%s\\n" "${__str}" |${SHASUMBIN}) || { return 1; }
    __hash="${__hash%%[ ]*}"
    eval "${__outvar}=\"\${__hash}\""
}

_DAEMON_ITERATE()
{
    local _SPACE_NAME="_DAEMON_ITERATE"

    # We recreate the tmpdir if it has been removed, since this is a long running usage of tmp it might get removed at some point.
    if [ -z "${_TMPDIR}" ] || [ ! -d "${_TMPDIR}" ]; then
        _TMPDIR="$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')"
    fi

    if ! _FETCH_POD_FILES; then
        _LOG "Error in fetching pod files" "error"
        return 1
    fi

    if ! _UPDATE_BUSY_LIST; then
        _LOG "Cannot update busy list" "error"
        return 1
    fi

    if ! _CHECK_CONFIG_CHANGES; then
        _LOG "Could not check pod config changes" "error"
        return 1
    fi

    if ! _SPAWN_PROCESSES; then
       _LOG "Could not spawn process" "error"
        return 1
    fi

    # Initially wait at least 10 seconds before updating the proxy.conf since it may flicker to empty otherwise on startup.
    local ts="$(date +%s)"
    if [ $((ts-_STARTTS >10)) ]; then
        if ! _WRITE_PROXY_CONFIG; then
            _LOG "Could not write proxy config" "error"
            return 1
        fi
    fi
}

_UPDATE_BUSY_LIST()
{
    local _SPACE_NAME="_UPDATE_BUSY_LIST"

    local newList=""
    local tuple=
    for tuple in ${_BUSYLIST}; do
        local nakedFile="${tuple%%,*}"
        local pid="${tuple##*,}"
        # Check if the process is still alive.
        if kill -0 "${pid}" 2>/dev/null; then
            newList="${newList}${newList:+ }${nakedFile},${pid}"
        else
            # The process ended, check if the state is stopped or removed,
            # if so then remove any ramdisks this process has created.
            _LOG "Process exited for ${nakedFile} with PID ${pid}" "debug"
            if [ "$(id -u)" = "0" ]; then
                local stateFile="${nakedFile}.state"
                local state="$(cat "${stateFile}")"
                if [ "${state}" != "running" ]; then
                    local podDir="${nakedFile%/*}"
                    _DESTROY_RAMDISKS "${podDir}"
                fi
            fi
        fi
    done
    _BUSYLIST="${newList}"
}

_TRAP_TERM()
{
    local _SPACE_NAME="_TRAP_TERM"
    _PHASE="shutdown"
}

FILE_STAT()
{
    local _SPACE_NAME="FILE_STAT"

    local file="${1}"
    shift

    local format="${1}"
    shift

    #
    # Check for BSD stat
    if command -v "pkg" >/dev/null || command -v "brew" >/dev/null ; then
        # Translate format options
        format=$(printf "%s" "${format}" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f "${format}" "${file}"
    else
        stat -c "${format}" "${file}"
    fi

    if [ "$?" -gt 0 ]; then
        PRINT "Failed to stat file: ${file}." "error"
        return 1
    fi
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

STRING_REPEAT()
{
    local _SPACE_NAME="STRING_REPEAT"

    local __string="${1}"
    shift

    local __count="${1}"
    shift

    local __separator="${1}"
    shift

    local __outvar="${1}"
    shift

    local __repeatedstring=""
    while [ "${__count}" -gt 0 ]; do
        __count=$((__count-1))
        __repeatedstring="${__repeatedstring}${__string}"
        if [ "${__count}" -gt 0 ]; then
            __repeatedstring="${__repeatedstring}${__separator}"
        fi
    done

    eval "${__outvar}=\"\${__repeatedstring}\""
}

_STRING_ESCAPE()
{
    local _SPACE_NAME="_STRING_ESCAPE"
    local __right=
    local __result=""
    eval "__right=\$${1}"
    local __left=
    while true; do
        # Cut from right up until last occurrence of char.
        __left="${__right%%${2}*}"
        if [ "${__left}" = "${__right}" ]; then
            # Done
            __result="${__result}${__left}"
            break
        fi
        __right="${__right#$__left}"
        # This seems to be necessary the remove the escapes properly.
        __right="${__right#*${2}}"
        # Now cut away from right all escapes, one by one..
        local __escapes=""
        local __left2=
        while true; do
            __left2="${__left%[\\]}"
            if [ "${__left2}" = "${__left}" ]; then
                # No more escapes
                break
            fi
            # Escape encountered
            __escapes="${__escapes}\\"
            __left="${__left2}"
        done
        # Double the number of escapes and add one.
        __result="${__result}${__left}${__escapes}${__escapes}\\${2}"
    done
    eval "${1}=\${__result}"
}

_FETCH_POD_FILES()
{
    local _SPACE_NAME="_FETCH_POD_FILES"
    local tuple=
    for tuple in ${_PODPATTERNS}; do
        local basedir="${tuple%%,*}"
        local pattern="${tuple##*,}"
        local stateFiles=
        if ! stateFiles="$(find "${basedir}" -regex "${pattern}" 2>/dev/null)"; then
            return 1
        fi
        local stateFile=
        _PODS=""
        for stateFile in ${stateFiles}; do
            local nakedFile="${stateFile%.state}"
            # Check so that the state file has a pod buddie file,
            # if so store it.
            if [ -f "${nakedFile}" ]; then
                _PODS="${_PODS}${_PODS:+ }${nakedFile}"
            fi
        done
    done
}

_CHECK_CONFIG_CHANGES()
{
    local _SPACE_NAME="_CHECK_CONFIG_CHANGES"

    local changedList=""
    local newList=""

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local configsDir="${podDir}/config"
        if [ ! -d "${podDir}" ]; then
            continue
        fi

        local isBusy=0
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list.
                isBusy=1
                break
            fi
        done

        # Get the checksum of each config dir in the pod dir.
        local configDir=
        for configDir in ${configsDir}/*; do
            if [ ! -d "${configDir}" ]; then
                continue
            fi

            # Get previous checksum, if any
            local chksumPrevious=
            local index=
            if STRING_ITEM_INDEXOF "${_CONFIGCHKSUMS}" "${configDir}" "index"; then
                STRING_ITEM_GET "${_CONFIGCHKSUMS}" "$((index+1))" "chksumPrevious"
            fi

            # If this pod is in busy list, just transfer the previous checksum over,
            # because if config has changed we don't want to burn that notification already.
            if [ "${isBusy}" = "1" ]; then
                newList="${newList}${newList:+ }${configDir} ${chksumPrevious}"
                continue
            fi

            local chksum=
            if ! chksum=$(FILE_DIR_CHECKSUM "${configDir}"); then
                return 1
            fi

            if ! [ "${chksum}" = "${chksumPrevious}" ]; then
                # Mismatch, store it in changed list, unless this was the first time
                if [ -n "${chksumPrevious}" ]; then
                    changedList="${changedList}${changedList:+ }${configDir}"
                fi
            fi
            newList="${newList}${newList:+ }${configDir} ${chksum}"
        done
    done

    _CONFIGCHKSUMS="${newList}"
    _CONFIGSCHANGED="${changedList}"
}

_SPAWN_PROCESSES()
{
    local _SPACE_NAME="_SPAWN_PROCESSES"

    local nakedFile=
    for nakedFile in ${_PODS}; do
        local podDir="${nakedFile%/*}"
        local tuple=
        for tuple in ${_BUSYLIST}; do
            local nakedFile2="${tuple%%,*}"
            if [ "${nakedFile}" = "${nakedFile2}" ]; then
                # Pod is in busy list.
                continue 2
            fi
        done

        local stateFile="${nakedFile}.state"
        local state="$(cat "${stateFile}")"
        local changedConfigs=""
        if [ "${state}" = "running" ]; then
            # Check for changed configs
            local configDir=
            for configDir in ${_CONFIGSCHANGED}; do
                # Check if this config dir is for the current pod
                local config="${configDir##${podDir}/config/}"
                if [ "${config}" != "${configDir}" ]; then
                    changedConfigs="${changedConfigs}${changedConfigs:+ }${config}"
                fi
            done
        fi

        local stateChanged="false"
        if _SPAWN_STATE_CHANGED "${nakedFile}" "${state}"; then
            stateChanged="true"
            _LOG "State changed. Exec ${nakedFile} ${state}" "info" 0
            _LOG_CLEAR "exec:${nakedFile}"
        fi

        if [ -n "${changedConfigs}" ]; then
            _LOG "Configs changed. Reload configs for ${nakedFile} ${state}" "info" 0
            _LOG_CLEAR "config:${nakedFile}"
        fi

        if [ "${stateChanged}" = "true" ] ||
           [ "${state}" = "running" ] ||
           [ -n "${changedConfigs}" ]; then
            if ! _SPAWN_PROCESS "${nakedFile}" "${state}" "${changedConfigs}"; then
                _LOG "Could not spawn process for ${nakedFile}" "error" "spawn:${nakedFile}"
                return 0
            fi
        fi
    done
}

_WRITE_PROXY_CONFIG()
{
    local _SPACE_NAME="_WRITE_PROXY_CONFIG"
    if [ -z "${_PROXYCONF}" ]; then
        return 0
    fi

    local proxyConf="${_TMPDIR}/proxy.conf"

    local file=
    local contents=
    cat "${_TMPDIR}"/proxy.*.conf 2>/dev/null |sort >"${proxyConf}"
    printf "%s\\n" "### EOF" >>"${proxyConf}"

    if diff "${_PROXYCONF}" "${proxyConf}" >/dev/null 2>&1; then
        return 0
    fi

    cp "${proxyConf}" "${_PROXYCONF}"
}

_DESTROY_RAMDISKS()
{
    local _SPACE_NAME="_DESTROY_RAMDISKS"

    if [ -d "${podDir}/ramdisk" ]; then
        local dir=
        for dir in "${podDir}/ramdisk/"*; do
            if mountpoint -q "${dir}"; then
                _LOG "Unmount ramdisk ${dir}" "info"
                umount "${dir}"
            fi
        done
    fi
}

FILE_DIR_CHECKSUM()
{
    local _SPACE_NAME="FILE_DIR_CHECKSUM"

    local dir="${1}"
    shift

    local _SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        _SHASUMBIN=sha256sum
    elif command -v sha1sum >/dev/null; then
        _SHASUMBIN=sha1sum
    elif command -v shasum >/dev/null; then
        _SHASUMBIN="shasum -a 256"
    elif command -v md5sum >/dev/null; then
        _SHASUMBIN="md5sum"
    else
        return 1
    fi

    (cd "${dir}" && ls -lAR "." |${_SHASUMBIN} |cut -f 1 -d' ')
}

_SPAWN_PROCESS()
{
    local _SPACE_NAME="_SPAWN_PROCESS"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local changedConfigs="${1}"
    shift

    local podFile="${nakedFile}"

    local exec="sh -c"
    if [ "$(id -u)" = "0" ]; then
        # Drop priviligies
        exec="su ${_USER} -c"
    fi

    local command=

    if [ "${state}" = "running" ]; then
        command="run"
        if [ "$(id -u)" = "0" ]; then
            # Check if to create ramdisks for this pod
            local ramdisks=
            ramdisks="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ramdisk-config")"
            if [ -n "${ramdisks}" ]; then
                local podDir="${nakedFile%/*}"
                local ramdisk=
                for ramdisk in ${ramdisks}; do
                    local name="${ramdisk%:*}"
                    local size="${ramdisk#*:}"
                    local error=
                    if ! error="$(_CREATE_RAMDISK "${podDir}" "${name}" "${size}" 2>&1)"; then
                        _LOG "Could not create ramdisk ${name}:${size} in ${podDir}, Error: ${error}" "error" "ramdisk:${podDir}:${name}:${size}"
                        return 1
                    else
                        _LOG "Created ramdisk ${name}:${size} in ${podDir}" "info" "ramdisk:${podDir}:${name}:${size}"
                    fi
                done
            fi
        fi
    elif [ "${state}" = "stopped" ]; then
        command="stop"
    elif [ "${state}" = "removed" ]; then
        command="rm"
    else
        _LOG "State file has unknown state." "debug"
        return 0
    fi

    local hash=
    if ! STRING_HASH "${nakedFile}" "hash"; then
        return 1
    fi

    local proxyConfigFragment="${_TMPDIR}/proxy.${hash}.conf"

    local pid=
    (
        local error=
        # If running as root we will drop privileges here, thanks to ${exec}.
        if ! error="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} ${command}" 2>&1)"; then
            _LOG "Could not exec ${podFile} ${command}. Error: ${error}" "error" "exec:${podFile}"
        fi
        if [ -n "${changedConfigs}" ]; then
            if ! error="$(SPACE_LOG_LEVEL="${_SUBPROCESS_LOG_LEVEL}" ${exec} "${podFile} reload-configs ${changedConfigs}" 2>&1)"; then
                _LOG "Could not exec ${podFile} reload-configs. Error: ${error}" "error" "config:${podFile}"
            fi
        fi

        # We mute stderr for the remaining ${exec} invocations by setting: SPACE_LOG_LEVEL="0"
        if [ "${state}" = "running" ]; then
            local cc=
            if [ -f "${podFile}.proxy.conf" ]; then
                cc="$(cat "${podFile}.proxy.conf")"
            fi
            if [ -n "${cc}" ]; then
                # Run ReadinessProbe and write proxy config fragment.
                if SPACE_LOG_LEVEL="0" ${exec} "${podFile} readiness"; then
                    printf "%s\\n" "${cc}" >"${proxyConfigFragment}.tmp"
                else
                    # Reset
                    printf "# Not ready: %s\\n" "${podFile}" >"${proxyConfigFragment}.tmp"
                fi
                mv -f "${proxyConfigFragment}.tmp" "${proxyConfigFragment}"
            fi

            # Run LivenessProbe
            SPACE_LOG_LEVEL="0" ${exec} "${podFile} liveness"
        fi
    )&
    pid=$!

    _BUSYLIST="${_BUSYLIST}${_BUSYLIST:+ }${nakedFile},${pid}"
}

_SPAWN_STATE_CHANGED()
{
    local _SPACE_NAME="_SPAWN_STATE_CHANGED"

    local nakedFile="${1}"
    shift

    local state="${1}"
    shift

    local prevState=""
    local line="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -m1 "^${nakedFile} ")"

    if [ -n "${line}" ]; then
        prevState="${line##*[ ]}"
        _CURRENT_STATES="$(printf "%s\\n" "${_CURRENT_STATES}" |grep -v "^${nakedFile} ")"
    fi

    # Save state
    local nl="
"
    _CURRENT_STATES="${_CURRENT_STATES}${_CURRENT_STATES:+$nl}${nakedFile} ${state}"

    # Set return status
    [ "${prevState}" != "${state}" ]
}

_LOG_CLEAR()
{
    local _SPACE_NAME="_LOG_CLEAR"

    local tag="${1}"
    shift

    local hash=
    STRING_HASH "${tag}" "hash"

    local logtext="$(grep -v "^${hash}\>" "${_LOGFILETAGS}")"
    printf "%s\\n" "${logtext}" >"${_LOGFILETAGS}"
}

_CREATE_RAMDISK()
{
    local _SPACE_NAME="_CREATE_RAMDISK"

    if [ ! -d "${podDir}/ramdisk" ]; then
        mkdir "${podDir}/ramdisk"
        chown "${_USER}:${_USER}" "${podDir}/ramdisk"
    fi

    if [ ! -d "${podDir}/ramdisk/${name}" ]; then
        mkdir "${podDir}/ramdisk/${name}"
        chown "${_USER}:${_USER}" "${podDir}/ramdisk/${name}"
    fi

    if mountpoint -q "${podDir}/ramdisk/${name}"; then
        # Already exists.
        return 0
    fi

    if ! mount -t tmpfs -o size="${size}" tmpfs "${podDir}/ramdisk/${name}"; then
        return 1
    fi

    chown "${_USER}:${_USER}" "${podDir}/ramdisk/${name}"
    chmod 700 "${podDir}/ramdisk/${name}"
}

main()
{
    SNTD_CMDLINE "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /cmdline/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /cmdline/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
